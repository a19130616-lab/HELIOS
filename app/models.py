"""
Data models and structures for the Helios Trading System.
"""

from dataclasses import dataclass
from enum import Enum
from typing import Any, Dict, List, Optional, Union
import time

class OrderSide(Enum):
    """Order side enumeration."""
    BUY = "BUY"
    SELL = "SELL"

class SignalDirection(Enum):
    """Signal direction enumeration."""
    LONG = "LONG"
    SHORT = "SHORT"
    EXIT_LONG = "EXIT_LONG"
    EXIT_SHORT = "EXIT_SHORT"

class MarketRegime(Enum):
    """Market regime classification."""
    TRENDING = "TRENDING"
    RANGING = "RANGING"
    UNKNOWN = "UNKNOWN"

@dataclass
class OrderBookLevel:
    """Represents a single level in the order book."""
    price: float
    quantity: float

@dataclass
class OrderBookSnapshot:
    """Represents a complete order book snapshot."""
    symbol: str
    timestamp: int
    bids: List[OrderBookLevel]
    asks: List[OrderBookLevel]
    
    def get_mid_price(self) -> float:
        """Calculate the mid-price between best bid and ask."""
        if not self.bids or not self.asks:
            return 0.0
        return (self.bids[0].price + self.asks[0].price) / 2.0
    
    def get_spread(self) -> float:
        """Calculate the bid-ask spread."""
        if not self.bids or not self.asks:
            return 0.0
        return self.asks[0].price - self.bids[0].price

@dataclass
class TradeData:
    """Represents a single trade execution."""
    symbol: str
    timestamp: int
    price: float
    quantity: float
    side: OrderSide
    trade_id: str

@dataclass
class TradingSignal:
    """Represents a trading signal generated by the system."""
    symbol: str
    direction: SignalDirection
    timestamp: int
    confidence: float
    nobi_value: float
    entry_price: float
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    signal_id: Optional[str] = None
    # Optional enrichment fields (ignored by execution if unused)
    reason: Optional[str] = None
    notes: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None
    
    def __post_init__(self):
        """Validate signal data after initialization."""
        if not 0 <= self.confidence <= 1:
            raise ValueError("Confidence must be between 0 and 1")
        if not -1 <= self.nobi_value <= 1:
            raise ValueError("NOBI value must be between -1 and 1")

@dataclass
class DecisionLog:
    """
    Represents a logged trading decision or exit event.
    Extended to support explicit EXIT_* directions and realized PnL
    for simulated/public modes when execution is disabled.
    """
    symbol: str
    direction: SignalDirection               # LONG | SHORT | EXIT_LONG | EXIT_SHORT
    timestamp: int
    confidence: float
    nobi_value: float
    entry_price: float                       # For EXIT_* this is treated as exit_price
    mode: str                                # 'live' | 'public' | 'synthetic'
    reason: Optional[str] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    notes: Optional[str] = None
    realized_pnl: Optional[float] = None     # Populated on EXIT_* events
    position_size: Optional[float] = None    # Size used for PnL calc (simulated/public)
    commission: Optional[float] = None       # Commission fee paid (simulated or real)

    def __post_init__(self):
        if not 0 <= self.confidence <= 1:
            raise ValueError("Confidence must be between 0 and 1")
        if not -1 <= self.nobi_value <= 1:
            raise ValueError("NOBI value must be between -1 and 1")
        if self.mode not in ("live", "public", "synthetic"):
            raise ValueError("mode must be one of 'live','public','synthetic'")

    def to_dict(self) -> Dict[str, Union[str, float, int, None]]:
        return {
            "symbol": self.symbol,
            "direction": self.direction.value,
            "timestamp": self.timestamp,
            "confidence": self.confidence,
            "nobi_value": self.nobi_value,
            "entry_price": self.entry_price,
            "mode": self.mode,
            "reason": self.reason,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "notes": self.notes,
            "realized_pnl": self.realized_pnl,
            "position_size": self.position_size,
            "commission": self.commission,
        }

@dataclass
class Position:
    """Represents an open trading position."""
    symbol: str
    side: OrderSide
    size: float
    entry_price: float
    current_price: float
    timestamp: int
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    high_water_mark: Optional[float] = None
    
    @property
    def unrealized_pnl(self) -> float:
        """Calculate unrealized PnL for the position."""
        if self.side == OrderSide.BUY:
            return (self.current_price - self.entry_price) * self.size
        else:
            return (self.entry_price - self.current_price) * self.size
    
    @property
    def unrealized_pnl_percentage(self) -> float:
        """Calculate unrealized PnL as a percentage."""
        if self.entry_price == 0:
            return 0.0
        return (self.unrealized_pnl / (self.entry_price * self.size)) * 100

@dataclass
class AssetScore:
    """Represents the scoring metrics for asset selection."""
    symbol: str
    volatility: float
    liquidity: float
    order_book_depth: float
    composite_score: float
    rank: int

@dataclass
class AccountInfo:
    """Represents account information and margin status."""
    total_balance: float
    available_balance: float
    used_margin: float
    margin_ratio: float
    positions: List[Position]
    timestamp: int
    
    @property
    def is_warning_level(self) -> bool:
        """Check if account is at warning margin level."""
        from app.config_manager import get_config
        config = get_config()
        warning_ratio = config.get('risk', 'warning_margin_ratio', float)
        return self.margin_ratio <= warning_ratio
    
    @property
    def is_critical_level(self) -> bool:
        """Check if account is at critical margin level."""
        from app.config_manager import get_config
        config = get_config()
        critical_ratio = config.get('risk', 'critical_margin_ratio', float)
        return self.margin_ratio <= critical_ratio

@dataclass
class SystemMetrics:
    """System performance and health metrics."""
    timestamp: int
    total_trades: int
    winning_trades: int
    losing_trades: int
    total_pnl: float
    win_rate: float
    avg_win: float
    avg_loss: float
    max_drawdown: float
    sharpe_ratio: Optional[float] = None
    
    @property
    def win_loss_ratio(self) -> float:
        """Calculate win/loss ratio."""
        if self.avg_loss == 0:
            return float('inf') if self.avg_win > 0 else 0
        return abs(self.avg_win / self.avg_loss)

class RiskLevel(Enum):
    """Risk level enumeration."""
    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"
    CRITICAL = "CRITICAL"

@dataclass
class RiskAssessment:
    """Risk assessment for the trading system."""
    timestamp: int
    level: RiskLevel
    margin_ratio: float
    position_count: int
    total_exposure: float
    max_single_position_risk: float
    message: str